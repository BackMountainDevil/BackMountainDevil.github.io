# C
date: 2020-11-21
lastmod: 2020-11-21

# Hello World
新建一个tmp.c文件，输入以下内容保存
```c
#include <stdio.h>
int main()
{
    printf("Helllo World");
    return 0;
}
```
然后在终端里编译该文件，执行生成的程序。后面的程序都是在Deep20amd64 gcc8.3.0上编译运行通过的。
```bash
$ gcc tmp.c
$ ./a.out
```
# 变量
## 命名
变量名的首字母必须是字母或者下划线，区分大小写，库例程的变量名基本都是下划线开头，因此在传统的C语言习惯中变量名使用小写字母，符号常量名全部使用大写字母。
## 静态变量
用`static`修饰内部变量之后，会一直存在再内存中可重复使用，不会随着所在函数的被调用和退出而存在和消失。  
如果是修饰函数名，则该函数名除了对当前函数声明所在的文件可见外，其它文件都无法访问。
## 变量类型
- char  字符型
- int   整形
- float     单精度浮点型（小数）
- double    双精度浮点型 （小数）
变量在使用前要先声明变量类型，单精度和双精度的却别在于双精度暂用的内存更多，存储的精度更高。此外还有short、long、unsigned、signed等修饰符。值得一提的是C没有布尔型和字符串型，但是却有字符串处理的库。
## 变量大小
C 或 C ++语言的同一种变量类型在不同OS上的范围（字节数）并不是固定的，而Java这一点上就是统一的，C语言中查看类型大小可以使用函数`sizeof(类型名称)`来查看类型所占字节数。
```c
#include <stdio.h>
int main()
{
    char c = 'a';
    int i = -1;
    float f = -2.0;
    double d = -3.0;
    printf("字符形数值%c ，所占字节大小为 %d字节\n", c, sizeof(char));
    printf("整形数值%d ，所占字节大小为 %d字节\n", i, sizeof(int));
    printf("单精度浮点型形数值%f ，所占字节大小为 %d字节\n", f, sizeof(float));
    printf("双精度浮点型形数值%lf ，所占字节大小为 %d字节\n", d, sizeof(double));
    return 0;
}
```
我的输出结果
```bash
字符形数值a ，所占字节大小为 1字节
整形数值-1 ，所占字节大小为 4字节
单精度浮点型形数值-2.000000 ，所占字节大小为 4字节
双精度浮点型形数值-3.000000 ，所占字节大小为 8字节
```
## 变量范围
由于变量所占内存字节数有限，因此变量存在着最大值和最小值，当超过了最大值和最小值便会发生错误。相关的最值都在limits.h里定义，我查到的位置是`/usr/lib/gcc/x86_64-linux-gnu/8/include-fixed/limits.h`，相当奇怪的是里面并没有float、double的范围定义，反而是定义了[s\us]long long型。
```c
#include <stdio.h>
#include <limits.h>
int main()
{
    printf("SCHAR_MIN = %d , SCHAR_MAX = %d \n", SCHAR_MIN, SCHAR_MAX);  // signed char
    printf("UCHAR_MAX = %d \n", UCHAR_MAX); // unsigned char
    printf("CHAR_MIN = %d , CHAR_MAX = %d \n", CHAR_MIN, CHAR_MAX);  // char

    printf("SHRT_MIN = %d , SHRT_MAX = %d \n", SHRT_MIN, SHRT_MAX);     // signed short int
    printf("USHRT_MAX = %d \n", USHRT_MAX);     // unsigned short int
    printf("INT_MIN = %d , INT_MAX = %d \n", INT_MIN, INT_MAX);  // signed int
    printf("UINT_MAX = %d \n", UINT_MAX);     // unsigned int
    return 0;
}
```
这是在amd64上的输出结果
```bash
SCHAR_MIN = -128 , SCHAR_MAX = 127 
UCHAR_MAX = 255 
CHAR_MIN = -128 , CHAR_MAX = 127 
SHRT_MIN = -32768 , SHRT_MAX = 32767 
USHRT_MAX = 65535 
INT_MIN = -2147483648 , INT_MAX = 2147483647 
UINT_MAX = -1 
```
## 变量作用域
外部变量使用extern声明来使用它。
# 常量
整数常量、符号常量、字符常量、字符串常量、常量表达式、枚举常量
```c
#define VTAB '\013\'
#define MAXLINE 1000

enum boolean {NO, YES};
```
# 函数
返回值类型 函数名（参数声明）
{
    声明部分
    语句序列
}
## 函数参数
C语言函数传进去的参数是传进去的变量的本地副本（形参），而不是原来的变量本身，因此在函数里对函数的操作不会改变原来的变量，除非是指针变量（引用传参的地址、数组）
# 数组
# 结构体

# 输入输出
输入输出居然不是C语言本身的组成部分唉。。。而是依赖于标准库来实现标准输入输出的。常用的标准输入输出库为`stdio.h`，位于usr/lib/stdio.h，而不是在gcc目录下。。。。
## 输入
### scanf
- d： int*类型；十进制整数
- i： int*类型；八进制（以0开头）或十六进制（以0x或0X开头）整数
- o： int*类型；八进制（以0开头）整数
- u： unsigned int*类型；无符号十进制整数
- x： int*类型；十六进制（以0x或0X开头，也可以不以0x或0X开头）整数
- c： char *类型，将接下来输入的多个字符（默认为1个字符）存放到指定位置。该转换规范常不跳过空白符。如果需要读入下一个非空白符，可以使用%ls
- s： char *类型，字符串（不加引号），指向一个足以存放该字符串（还包括尾部的字符'\0'）的字符数组。字符串的末尾将被添加一个结束符'\0'
- e，f，g： float*类型，浮点数，它可以包括正负号、小数点及指数部分
- %： 字符%；不进行任何赋值操作。

## 输出
int printf(格式化字符串)
格式化字符串包换普通字符和转换说明（%），普通字符直接输出，转换说明由对应的变量替换后输出
转换说明由一个%开始，并由一个转换字符结束。如果有必要，字段多余的字符位置用空格填充。在%和转换字符中间可能包含下列部分：
- 负号: 指定被转换的参数按照左对齐的形式输出，省略的时候默认为右对齐。
- m.n: 左边的正整数指定小数点左边的最小字段宽度，右边的指定小数位数；如果是字符串，左边指定输出区域所占宽度，右边指定输出字符的个数

转换字符一览
- d, i： int类型；十进制数
- o： int类型；无符号八进制数（没有前导0）
- x, X: int类型；无符号十六进制数（没有前导0x或0X），10~15分别用a~f或者A~F表示
- u： int类型；无符号十进制数
- c： int类型；单个字符
- s： char*类型；顺序打印字符串中的字符，，直到遇到'\0'或者已打印了由精度指定的字符数未知
- f： double类型；十进制小数[-]m.dddddd，其中d的个数有精度指定（默认为6）
- e，E： double类型；科学计数法，[-]m.dddddd e ± xx 或 [-]m.dddddd E ± xx，其中d的个数有精度指定（默认为6）
- g，G： double类型；如果指数小于-4或大于等于精度，则用%e或%E格式输出，否则用%f格式输出。
- p： void *类型；指针（取决于具体实现）
- %： 打印一个百分号%

在转换说明中，宽度或精度可以用星号*表示，这时，宽度或精度的值通过转换下一个int型参数来计算。例如，为了从字符串s中打印最多max个字符，可以使用下面的语句：
`printf("%.*s", max, s);`
## 转义字符
在不少语言中用反斜杠`\`表示转义字符，即不是看上去的意思，如果要输出一个反斜杠，就需要在格式字符串里写`\
\`.
| 表达式 | 含义 | 表达式 | 含义 |
|:----:| ----:| ----:| ----:|
| \a    | 响铃符  | \v    |  纵向制表符    |
| \b    | 回退符  | \\\    |  反斜杠    |
| \f    | 换页符  | \?    |   问好   |
| \n    | 换行符  | \'    |   单引号   |
| \r    | 回车符  | \"    |   双引号   |
| \t    | 横向制表符  | \ooo    |  八进制数    |
|       |    | \xhh    |   十六进制数   |
# 运算符
## 算数运算符
+、-、*、/（除）、&（取模运算符）  
整数除法会截断结果中的小数部分，即整数除整数结果还是整数。

## 关系运算符与逻辑运算符
`>、 >=、 <、 <=、 ==、 !=、 &&、 ||、 !`
## 自增运算符与自减运算符
++使变量数递增1，--使变量的值减一；当作为后缀运算符时，先使用变量的值，再改变变量的值，当作为前缀运算符时 ，先改变变量的值，再使用变量的值。

## 按位运算符
只能用于整形，
| 表达式 | 含义 |
|:----:| ----:|
| &    | 按位与(AND)  |
| \|    | 按位或(OR)  |
| ^   | 按位异或(XOR)  |
| <<    | 左移  |
| >>   | 右移  |
| ~   | 按位求反(一元运算符)  |

将x的最后六位设置为零`x = x & ~077`

## 条件表达式
三元运算符" ? : "  
` condition ? exp2 : exp3` :如果表达式condition为真，返回exp2，否则返回exp3
```c
if(a > b)
    z = a;
else
    z = b;
// 相当于下面的语句
z = (a > b) ? a : b;
```
# 三种结构
## 顺序
## 分支
### if
```c
if(表达式)
    {to do}
else if(表达式)
    {to do}
else if(表达式)
    {to do}
else if(表达式)
    {to do}
...
else
    {to do}
```
### switch
```c
switch(表达式){
    case 常量表达式: todo; break;
    case 常量表达式: todo; break;
    ...
    case 常量表达式: todo; break;
    default: todo; break;
}
```
## 循环
### for
无论如何首先执行表达式1，然后判断表达式2是否为真，为真时执行一遍循环体和一遍表达式3，继续判断表达式2真假，往复循环...直到表达式2为假时不在继续循环。
```c
for(表达式1;表达式2;表达式3){
    //循环体
}
```
表达式1~3可以都不写，只写分号，可在循环体内部加break跳出循环。
### while
首先判断表达式是否为真，为真时执行一遍循环体，再继续判断表达式真假决定是否继续循环。表达式可以不写，可在循环体内部加break跳出循环。
```c
while(表达式){
    //循环体
}
```
### do-while
这个循环结构无论如何先执行一遍循环体，然后再判断表达式真假，为真时再继续循环。
```c
do{
    //循环体
}while(表达式)
```
### break、continue、goto
break可以跳出一层循环，continue可以继续循环，goto能不用就不用，会导致结构混乱，可用来跳出多层循环。

# C预处理器
## 文件包含
```c
#incnlude <filenae>
#incnlude "filenae"
```
用尖括号括起来的先会按照对应规则寻找该文件，没找到再到源文件所在位置查找，双引号括起来的则是直接在源文件所在位置查找
## 宏替换/宏定义
`#define 名字 替换文本`   
后续所有出现`名字`记号的地方都将被替换为`替换文本`。宏定义也可以带参数，如
```c
#define max(A, B) ((A) > (B) ? (A) : (B))
x = max(p+q, r+s);
// 上面的式子会被替换为
x = ((p + q) > (r + s) ? (p+q) : (r+s));
```
但是这样会有一些缺陷，比如上面的参数表达式要计算两次，如果表达式存在副作用（比如含有自增运算符或者输入/输出），则会出现不正确的结果。
### 取消宏定义
可以通过`#undef`指令取消名字的宏定义，这样做可以保证后续的调用时函数调用，而不是宏调用。
```c
#undef getchar
int getchar(void) {...}
```
# 指针
> 指针一种保存变量地址的变量。  

一元运算符&可用于取一个对象的地址。如` p = &c; `
# 文件读写


